<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JayDL</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar">
        <div class="navbar-content">
            <div class="navbar-left">
                <button class="navbar-menu-btn" id="menuBtn" title="Menu">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="navbar-brand">
                    <h1><i class="fas fa-download"></i> JayDL</h1>
                </div>
            </div>
            <p class="navbar-subtitle">Download videos and music from various platforms</p>
            <button class="navbar-yt-btn" id="ytAuthBtn" title="Enable YouTube Downloads">
                <i class="fab fa-youtube"></i>
            </button>
            <button class="navbar-chat-btn" id="chatBtn" title="Open Chatbot">
                <i class="fas fa-comments"></i>
            </button>
        </div>
        
        <!-- Dropdown Menu -->
        <div class="navbar-dropdown hidden" id="navbarDropdown">
            <a href="#" class="dropdown-item" onclick="scrollToSection('platforms'); return false;">
                <i class="fas fa-globe"></i> Supported Platforms
            </a>
            <a href="#" class="dropdown-item" onclick="openChatbot(); return false;">
                <i class="fas fa-comments"></i> Chatbot Assistant
            </a>
        </div>
    </nav>

    <div class="container">
        <main>
            <div class="card input-section">
                <div class="url-input-container">
                    <input type="text" id="urlInput" placeholder="Paste YouTube, TikTok, Instagram, Twitter, or Spotify URL here...">
                    <button id="pasteBtn" class="btn btn-icon" title="Paste from clipboard">
                        <i class="fas fa-paste"></i>
                    </button>
                    <button id="analyzeBtn" class="btn btn-primary">
                        <i class="fas fa-search"></i> Analyze
                    </button>
                </div>

                <div id="errorAlert" class="alert alert-error hidden"></div>
                <div id="successAlert" class="alert alert-success hidden"></div>

                <div class="media-type-section">
                    <h3>Download Type</h3>
                    <div class="options-grid">
                        <button class="option-btn active" data-type="video">
                            <i class="fas fa-video"></i> Video
                        </button>
                        <button class="option-btn" data-type="audio">
                            <i class="fas fa-music"></i> Audio Only
                        </button>
                    </div>
                </div>

                <div id="mediaInfo" class="media-info hidden">
                    <div class="media-preview">
                        <img id="mediaThumbnail" src="" alt="Thumbnail" class="thumbnail" crossorigin="anonymous">
                        <div class="media-details">
                            <h3 id="mediaTitle">Media Title</h3>
                            <div class="meta-info">
                                <span id="mediaDuration" style="display: none;"><i class="fas fa-clock"></i> <span id="durationValue">0:00</span></span>
                                <span id="mediaUploader" style="display: none;"><i class="fas fa-user"></i> <span id="uploaderValue">Unknown</span></span>
                                <span id="mediaPlatform" style="display: none;"><i class="fas fa-globe"></i> <span id="platformValue">Unknown</span></span>
                            </div>
                        </div>
                    </div>

                    <div class="quality-section">
                        <h3>Quality Options</h3>
                        <div id="formatTabs" class="format-tabs" style="display: none;">
                            <button class="format-tab-btn active" data-format="all">All</button>
                            <button class="format-tab-btn" data-format="mp4">MP4</button>
                            <button class="format-tab-btn" data-format="webm">WebM</button>
                        </div>
                        <div id="qualityOptions" class="options-grid"></div>
                    </div>

                    <button id="downloadBtn" class="btn btn-download">
                        <i class="fas fa-download"></i> Download Now
                    </button>
                </div>
            </div>

            <div class="card platforms-section">
                <h3>Supported Platforms</h3>
                <div id="platformsGrid" class="platforms-grid"></div>
            </div>
        </main>
    </div>

    <div id="loadingModal" class="modal hidden">
        <div class="modal-content">
            <div class="loading-spinner"></div>
            <h3 id="loadingMessage">Processing...</h3>
            <p>Please wait while we process your request</p>
        </div>
    </div>

    <div id="chatbotModal" class="chatbot-modal hidden">
        <div class="chatbot-container">
            <div class="chatbot-header">
                <h2><i class="fas fa-comments"></i> JayDL Assistant</h2>
                <button class="chatbot-close-btn" onclick="closeChatbot()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="chatbot-maintenance">
                <div class="maintenance-icon">
                    <i class="fas fa-tools"></i>
                </div>
                <h3>Under Maintenance</h3>
                <p>The chatbot is currently undergoing maintenance and will be back online soon.</p>
                <p>Thank you for your patience!</p>
            </div>
        </div>
    </div>

    <script>
        // Detect backend URL - support both local and deployed environments
        const getBackendUrl = () => {
            const protocol = window.location.protocol;
            const hostname = window.location.hostname;
            const port = window.location.port;
            
            // If running on localhost frontend on port 8000, backend is on 5000
            if (hostname === 'localhost' || hostname === '127.0.0.1') {
                return `${protocol}//${hostname}:5000`;
            }
            
            // For Render deployment: frontend is jaydl-frontend.onrender.com, backend is jaydl-backend.onrender.com
            if (hostname.includes('onrender.com')) {
                return 'https://jaydl-backend.onrender.com';
            }
            
            // Otherwise, backend is on same host
            return `${protocol}//${hostname}${port ? ':' + port : ''}`;
        };

        const API_BASE = getBackendUrl();
        let currentMediaInfo = null;
        let selectedQuality = 'best';
        let selectedMediaType = 'video';

        function formatFileSize(bytes) {
            if (!bytes || bytes === 'Unknown' || bytes === 0) return 'Unknown';
            const kb = 1024;
            const mb = kb * 1024;
            const gb = mb * 1024;
            
            if (bytes >= gb) return (bytes / gb).toFixed(2) + ' GB';
            if (bytes >= mb) return (bytes / mb).toFixed(2) + ' MB';
            if (bytes >= kb) return (bytes / kb).toFixed(2) + ' KB';
            return bytes + ' B';
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadPlatforms();
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('pasteBtn').addEventListener('click', pasteFromClipboard);
            document.getElementById('analyzeBtn').addEventListener('click', analyzeMedia);
            document.getElementById('downloadBtn').addEventListener('click', downloadMedia);
            
            document.getElementById('urlInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') analyzeMedia();
            });

            document.querySelectorAll('.option-btn[data-type]').forEach(btn => {
                btn.addEventListener('click', () => selectMediaType(btn));
            });

            // Format tab listeners
            document.querySelectorAll('.format-tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.format-tab-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    const format = e.target.dataset.format;
                    filterFormatOptions(format);
                });
            });
        }

        async function pasteFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                document.getElementById('urlInput').value = text;
                showSuccess('URL pasted from clipboard!');
            } catch (err) {
                showError('Failed to paste from clipboard');
            }
        }

        function selectMediaType(btn) {
            document.querySelectorAll('.option-btn[data-type]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            selectedMediaType = btn.dataset.type;
            
            // Reset format tabs when switching type
            document.querySelectorAll('.format-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.format-tab-btn[data-format="all"]').classList.add('active');
            
            // Refresh quality options when switching type
            if (currentMediaInfo) {
                displayQualityOptions(currentMediaInfo);
            }
        }

        function filterFormatOptions(format) {
            const buttons = document.querySelectorAll('#qualityOptions .option-btn');
            buttons.forEach(btn => {
                const container = btn.dataset.container || 'unknown';
                if (format === 'all') {
                    btn.style.display = '';
                } else if (format === 'mp4' && (container === 'mp4' || btn.dataset.formatId === 'mp4')) {
                    btn.style.display = '';
                } else if (format === 'webm' && container === 'webm') {
                    btn.style.display = '';
                } else {
                    btn.style.display = 'none';
                }
            });
        }

        function displayQualityOptions(data) {
            const qualityOptions = document.getElementById('qualityOptions');
            const formatTabs = document.getElementById('formatTabs');
            qualityOptions.innerHTML = '';
            
            if (data.formats && data.formats.length > 0) {
                // Sort formats: videos first, then audio
                const sorted = data.formats.sort((a, b) => {
                    if (a.type === 'video' && b.type !== 'video') return -1;
                    if (a.type !== 'video' && b.type === 'video') return 1;
                    return 0;
                });

                // Check if we have both mp4 and webm formats (only for videos)
                const videoFormats = sorted.filter(f => f.type === 'video');
                const hasMP4 = videoFormats.some(f => f.container === 'mp4' || f.format_id === 'mp4');
                const hasWebM = videoFormats.some(f => f.container === 'webm');
                
                // Show format tabs ONLY when in video mode AND we have both formats
                if (selectedMediaType === 'video' && hasMP4 && hasWebM) {
                    formatTabs.style.display = 'flex';
                } else {
                    formatTabs.style.display = 'none';
                }

                sorted.forEach(format => {
                    // Skip audio formats when in video mode, skip video when in audio mode
                    if (selectedMediaType === 'video' && format.type === 'audio') {
                        return; // Skip audio when video is selected
                    }
                    if (selectedMediaType === 'audio' && format.type === 'video') {
                        return; // Skip video when audio is selected
                    }

                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.dataset.formatType = format.type;
                    btn.dataset.formatId = format.format_id;
                    btn.dataset.container = format.container || 'unknown';
                    
                    const resolution = format.resolution || format.format || 'Unknown';
                    const formatId = format.format_id || format.type || resolution.toLowerCase();
                    
                    let label = resolution;
                    
                    // Format and add file size if available with proper formatting
                    const filesize = formatFileSize(format.filesize);
                    if (filesize !== 'Unknown') {
                        label += `<br><small class="filesize-badge">ðŸ“¦ ${filesize}</small>`;
                    }
                    
                    // Add format type badge
                    if (format.type === 'audio') {
                        label += `<br><span class="quality-badge">AUDIO</span>`;
                    } else if (format.container) {
                        const containerUpper = format.container.toUpperCase();
                        label += `<br><span class="quality-badge">${containerUpper}</span>`;
                    }
                    
                    btn.innerHTML = label;
                    btn.onclick = () => selectQuality(btn, formatId, format.type);
                    qualityOptions.appendChild(btn);
                });

                // Auto-select first option
                const firstBtn = qualityOptions.firstChild;
                if (firstBtn) {
                    firstBtn.classList.add('active');
                    const firstFormat = data.formats.find(f => 
                        (selectedMediaType === 'audio' && f.type === 'audio') || 
                        (selectedMediaType === 'video' && f.type === 'video')
                    ) || data.formats[0];
                    selectedQuality = firstFormat.format_id || firstFormat.type || 'best';
                    console.log('Auto-selected quality:', selectedQuality);
                }
            }
        }

        async function analyzeMedia() {
            const url = document.getElementById('urlInput').value.trim();
            
            if (!url) {
                showError('Please enter a URL');
                return;
            }

            // Basic URL validation
            if (!isValidUrl(url)) {
                showError('Please enter a valid URL');
                return;
            }

            showLoading('Analyzing media...');
            hideError();
            hideSuccess();

            try {
                console.log('Analyzing URL:', url);
                console.log('Backend URL:', API_BASE);
                
                const response = await fetch(`${API_BASE}/api/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                hideLoading();

                if (data.success) {
                    displayMediaInfo(data);
                    showSuccess('Media analyzed successfully!');
                } else {
                    showError(data.error || 'Failed to analyze media');
                }
            } catch (err) {
                hideLoading();
                console.error('Analysis error:', err);
                showError(`Network error: ${err.message}. Make sure the backend is running on ${API_BASE}`);
            }
        }

        function displayMediaInfo(data) {
            currentMediaInfo = data;
            
            // Debug log
            console.log('Media info received:', data);
            
            // Set media information
            const thumbnailImg = document.getElementById('mediaThumbnail');
            let thumbnailUrl = data.thumbnail || '';
            
            // If no thumbnail, use platform-specific logo
            if (!thumbnailUrl) {
                if (data.platform === 'instagram') {
                    // Use Instagram logo as fallback
                    thumbnailUrl = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Cdefs%3E%3ClinearGradient id="insta-gradient" x1="0%" y1="100%" x2="100%" y2="0%"%3E%3Cstop offset="0%" style="stop-color:%23feda75;stop-opacity:1" /%3E%3Cstop offset="5%" style="stop-color:%23fa7e1e;stop-opacity:1" /%3E%3Cstop offset="45%" style="stop-color:%23d92e7f;stop-opacity:1" /%3E%3Cstop offset="60%" style="stop-color:%239b36b7;stop-opacity:1" /%3E%3Cstop offset="90%" style="stop-color:%23515bd4;stop-opacity:1" /%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width="200" height="200" fill="url(%23insta-gradient)"%3E%3C/rect%3E%3Crect x="40" y="40" width="120" height="120" rx="30" fill="none" stroke="white" stroke-width="8"%3E%3C/rect%3E%3Ccircle cx="100" cy="100" r="30" fill="none" stroke="white" stroke-width="8"%3E%3C/circle%3E%3Ccircle cx="145" cy="55" r="8" fill="white"%3E%3C/circle%3E%3C/svg%3E';
                } else if (data.platform === 'tiktok') {
                    // Use TikTok logo colors
                    thumbnailUrl = 'https://via.placeholder.com/200x150?text=TikTok&bg=000000&txtcolor=25F4EE';
                } else if (data.platform === 'twitter') {
                    // Use Twitter/X logo colors
                    thumbnailUrl = 'https://via.placeholder.com/200x150?text=Twitter&bg=000000&txtcolor=FFFFFF';
                } else if (data.platform === 'spotify') {
                    // Use Spotify logo colors
                    thumbnailUrl = 'https://via.placeholder.com/200x150?text=Spotify&bg=1DB954&txtcolor=FFFFFF';
                } else {
                    // Generic placeholder
                    thumbnailUrl = 'https://via.placeholder.com/200x150?text=No+Image';
                }
            }
            
            // Add error handler in case thumbnail fails to load
            thumbnailImg.onerror = function() {
                console.log('Thumbnail failed to load, showing platform logo');
                // Fallback to platform-specific fallback
                if (data.platform === 'instagram') {
                    this.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"%3E%3Cdefs%3E%3ClinearGradient id="insta-gradient" x1="0%" y1="100%" x2="100%" y2="0%"%3E%3Cstop offset="0%" style="stop-color:%23feda75;stop-opacity:1" /%3E%3Cstop offset="5%" style="stop-color:%23fa7e1e;stop-opacity:1" /%3E%3Cstop offset="45%" style="stop-color:%23d92e7f;stop-opacity:1" /%3E%3Cstop offset="60%" style="stop-color:%239b36b7;stop-opacity:1" /%3E%3Cstop offset="90%" style="stop-color:%23515bd4;stop-opacity:1" /%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width="200" height="200" fill="url(%23insta-gradient)"%3E%3C/rect%3E%3Crect x="40" y="40" width="120" height="120" rx="30" fill="none" stroke="white" stroke-width="8"%3E%3C/rect%3E%3Ccircle cx="100" cy="100" r="30" fill="none" stroke="white" stroke-width="8"%3E%3C/circle%3E%3Ccircle cx="145" cy="55" r="8" fill="white"%3E%3C/circle%3E%3C/svg%3E';
                } else {
                    this.src = 'https://via.placeholder.com/200x150?text=No+Image';
                }
            };
            
            thumbnailImg.src = thumbnailUrl;
            console.log('Setting thumbnail URL:', thumbnailUrl);
            
            document.getElementById('mediaTitle').textContent = data.title || 'Unknown Title';
            
            // Show/hide media type section - HIDE for Spotify
            const mediaTypeSection = document.querySelector('.media-type-section');
            const qualitySection = document.querySelector('.quality-section');
            if (data.platform === 'spotify') {
                mediaTypeSection.style.display = 'none';
                qualitySection.style.display = 'none';
                selectedMediaType = 'audio'; // Force audio for Spotify
            } else {
                mediaTypeSection.style.display = 'block';
                qualitySection.style.display = 'block';
            }
            
            // Show/hide duration if available
            const duration = data.duration || data.length;
            console.log('Duration value:', duration, 'Type:', typeof duration);
            if (duration && String(duration).trim() !== '' && String(duration) !== 'Unknown' && String(duration) !== 'N/A') {
                document.getElementById('durationValue').textContent = duration;
                document.getElementById('mediaDuration').style.display = 'flex';
                console.log('âœ“ Showing duration:', duration);
            } else {
                document.getElementById('mediaDuration').style.display = 'none';
                console.log('âœ— Hiding duration - value was:', duration);
            }
            
            // Show/hide uploader if available
            const uploader = data.uploader || data.upload_author || data.channel || data.creator;
            console.log('Uploader value:', uploader, 'Type:', typeof uploader);
            if (uploader && String(uploader).trim() !== '' && String(uploader) !== 'Unknown' && String(uploader) !== 'N/A') {
                document.getElementById('uploaderValue').textContent = uploader;
                document.getElementById('mediaUploader').style.display = 'flex';
                console.log('âœ“ Showing uploader:', uploader);
            } else {
                document.getElementById('mediaUploader').style.display = 'none';
                console.log('âœ— Hiding uploader - value was:', uploader);
            }
            
            // Show/hide platform if available
            if (data.platform && data.platform !== 'Unknown') {
                document.getElementById('platformValue').textContent = data.platform;
                document.getElementById('mediaPlatform').style.display = 'flex';
            } else {
                document.getElementById('mediaPlatform').style.display = 'none';
            }

            // Debug: log the formats
            console.log('Received formats:', data.formats);
            data.formats.forEach((fmt, idx) => {
                console.log(`Format ${idx}:`, fmt);
            });

            // Display quality options
            displayQualityOptions(data);

            document.getElementById('mediaInfo').classList.remove('hidden');
            document.getElementById('downloadBtn').disabled = false;
        }

        function selectQuality(btn, quality, formatType) {
            document.querySelectorAll('#qualityOptions .option-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            selectedQuality = quality;
            
            // Also update media type based on the quality selected
            if (formatType === 'audio') {
                selectedMediaType = 'audio';
            } else if (formatType === 'video') {
                selectedMediaType = 'video';
            }
            
            console.log('Selected quality:', quality, 'Format type:', formatType, 'Media type:', selectedMediaType);
        }

        function selectFirstAudioQuality() {
            const audioBtn = document.querySelector('#qualityOptions .option-btn[data-format-type="audio"]');
            if (audioBtn) {
                document.querySelectorAll('#qualityOptions .option-btn').forEach(b => b.classList.remove('active'));
                audioBtn.classList.add('active');
                const formatId = audioBtn.dataset.formatId || 'bestaudio';
                selectQuality(audioBtn, formatId, 'audio');
            }
        }

        async function downloadMedia() {
            if (!currentMediaInfo) {
                showError('Please analyze a URL first');
                return;
            }

            const url = document.getElementById('urlInput').value.trim();
            
            // Debug logging
            console.log('=== DOWNLOAD DEBUG ===');
            console.log('selectedQuality:', selectedQuality);
            console.log('selectedMediaType:', selectedMediaType);
            
            // Pass quality as-is (backend will interpret it)
            let quality = selectedQuality;
            console.log('Final quality to send:', quality);
            
            showLoading('Preparing download...');
            hideError();
            hideSuccess();

            try {
                const downloadPayload = {
                    url,
                    quality: quality,
                    media_type: selectedMediaType
                };
                console.log('Download payload:', downloadPayload);
                console.log('=== END DEBUG ===');
                
                const response = await fetch(`${API_BASE}/api/download`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(downloadPayload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                hideLoading();

                if (data.success) {
                    // Trigger download
                    if (data.download_url) {
                        window.location.href = `${API_BASE}${data.download_url}`;
                        showSuccess('Download started! Check your downloads folder.');
                    } else if (data.filename) {
                        // Construct download URL if not provided
                        const downloadUrl = `${API_BASE}/api/file/${data.filename}`;
                        window.location.href = downloadUrl;
                        showSuccess('Download started! Check your downloads folder.');
                    } else {
                        showSuccess('Download prepared successfully!');
                    }
                    
                    // Show rate limit warning if applicable
                    if (data.remaining_downloads !== undefined && data.remaining_downloads !== null) {
                        const remaining = data.remaining_downloads;
                        if (remaining > 0 && remaining <= 5) {
                            showError(`âš ï¸ Spotify Rate Limit: Only ${remaining} downloads remaining today. Resets at midnight.`);
                        }
                    }
                } else {
                    // Check for rate limit error
                    if (data.rate_limit_hit) {
                        showError(`â›” Spotify Rate Limit Reached! You've reached 20 downloads today. This limit resets at midnight (${data.resets_at}). Please try again tomorrow.`);
                    } else {
                        showError(data.error || 'Download failed. Please try again.');
                    }
                }
            } catch (err) {
                hideLoading();
                console.error('Download error:', err);
                showError(`Network error: ${err.message}`);
            }
        }

        async function loadPlatforms() {
            try {
                const response = await fetch(`${API_BASE}/api/platforms`);
                const data = await response.json();
                
                if (data.success && data.platforms) {
                    const grid = document.getElementById('platformsGrid');
                    grid.innerHTML = data.platforms.map(p => `
                        <div class="platform-card">
                            <i class="${p.icon}" style="color: ${p.color}"></i>
                            <div style="font-weight: 500; margin-top: 10px;">${p.name}</div>
                            ${p.supported ? '<small style="color: #10b981;">âœ“ Supported</small>' : '<small style="color: #ef4444;">âœ— Coming Soon</small>'}
                        </div>
                    `).join('');
                }
            } catch (err) {
                console.error('Failed to load platforms:', err);
                // Show error message in platforms grid
                document.getElementById('platformsGrid').innerHTML = '<p style="color: #666;">Unable to load platforms. Make sure the backend is running.</p>';
            }
        }

        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        function showLoading(message) {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingModal').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingModal').classList.add('hidden');
        }

        function showError(message) {
            const alert = document.getElementById('errorAlert');
            alert.textContent = message;
            alert.classList.remove('hidden');
            setTimeout(() => hideError(), 8000);
        }

        function hideError() {
            document.getElementById('errorAlert').classList.add('hidden');
        }

        function showSuccess(message) {
            const alert = document.getElementById('successAlert');
            alert.textContent = message;
            alert.classList.remove('hidden');
            setTimeout(() => hideSuccess(), 5000);
        }

        function hideSuccess() {
            document.getElementById('successAlert').classList.add('hidden');
        }

        // Navbar menu functionality
        document.getElementById('menuBtn').addEventListener('click', () => {
            const dropdown = document.getElementById('navbarDropdown');
            dropdown.classList.toggle('hidden');
        });

        document.getElementById('chatBtn').addEventListener('click', openChatbot);
        document.getElementById('ytAuthBtn').addEventListener('click', enableYouTubeAuth);

        // Check if YouTube is already authenticated
        function checkYouTubeAuth() {
            const stored = localStorage.getItem('yt_authenticated');
            if (stored === 'true') {
                document.getElementById('ytAuthBtn').classList.add('authenticated');
            }
        }
        
        function enableYouTubeAuth() {
            // Show permission dialog
            const permission = confirm(`ðŸ” YouTube Authentication

JayDL would like to collect your YouTube session cookies to enable video downloads.

This allows us to:
âœ“ Download YouTube videos without bot detection
âœ“ Bypass authentication requirements

Your cookies are stored locally in your browser.

Allow YouTube authentication?`);
            
            if (!permission) {
                return;
            }
            
            // Try to collect cookies automatically
            collectYouTubeCookies();
        }
        
        function enableYouTubeAuth() {
            // Show permission dialog
            const permission = confirm(`ðŸ” YouTube Authentication

JayDL will enable YouTube video downloads using your session.

This requires you to:
âœ“ Be logged into YouTube in your browser
âœ“ Click "Yes" to authorize

Allow YouTube authentication?`);
            
            if (!permission) {
                return;
            }
            
            // Start authentication
            authenticateYouTube();
        }
        
        async function authenticateYouTube() {
            showLoading('Preparing YouTube authentication...');
            
            // First, try to get cookies directly if available
            const cookies = await tryGetCookiesDirectly();
            if (cookies) {
                hideLoading();
                sendCookiesToBackend(cookies);
                return;
            }
            
            // If direct method fails, open YouTube in a hidden iframe to trigger cookie setting
            hideLoading();
            await triggerYouTubeCookieSync();
        }
        
        async function tryGetCookiesDirectly() {
            try {
                // Method 1: Cookie Store API
                if (navigator.cookieStore) {
                    const allCookies = await navigator.cookieStore.getAll();
                    const youtubeCookies = allCookies.filter(c => 
                        c.domain && (c.domain.includes('youtube') || c.domain.includes('google'))
                    );
                    
                    if (youtubeCookies.length > 0) {
                        console.log('Found YouTube cookies via Cookie Store API');
                        return youtubeCookies.map(c => `${c.name}=${c.value}`).join('; ');
                    }
                }
            } catch (e) {
                console.log('Cookie Store API error:', e);
            }
            
            // Method 2: Document.cookie (if same-origin)
            if (document.cookie && document.cookie.length > 50) {
                console.log('Found cookies in document.cookie');
                return document.cookie;
            }
            
            return null;
        }
        
        async function triggerYouTubeCookieSync() {
            return new Promise((resolve) => {
                showLoading('Opening YouTube to sync your session...');
                
                // Open YouTube in a popup - user might need to interact
                const youtubeWindow = window.open('https://www.youtube.com/feed/subscriptions', 'yt_sync', 'width=600,height=400');
                
                if (!youtubeWindow) {
                    hideLoading();
                    showError('Popup blocked! Please allow popups and try again.');
                    resolve();
                    return;
                }
                
                let checkCount = 0;
                const maxChecks = 30; // 15 seconds max
                
                // Check every 500ms if window is still open
                const checkInterval = setInterval(async () => {
                    checkCount++;
                    
                    try {
                        // Try to get cookies after each check
                        const cookies = await tryGetCookiesDirectly();
                        if (cookies && cookies.length > 50) {
                            console.log('Successfully retrieved cookies after YouTube sync');
                            clearInterval(checkInterval);
                            youtubeWindow.close();
                            hideLoading();
                            sendCookiesToBackend(cookies);
                            resolve();
                            return;
                        }
                    } catch (e) {
                        console.log('Error checking cookies:', e);
                    }
                    
                    // If window closed, try once more to get cookies
                    if (youtubeWindow.closed) {
                        clearInterval(checkInterval);
                        console.log('YouTube window closed, final cookie attempt...');
                        
                        // Wait a moment and try one more time
                        setTimeout(async () => {
                            const finalCookies = await tryGetCookiesDirectly();
                            hideLoading();
                            
                            if (finalCookies && finalCookies.length > 50) {
                                sendCookiesToBackend(finalCookies);
                            } else {
                                showError('Could not retrieve YouTube cookies. Please ensure:\n1. You\'re logged into YouTube\n2. Popups are allowed\n3. Try clearing browser cache and logging in again');
                            }
                            resolve();
                        }, 500);
                        return;
                    }
                    
                    // Timeout after 15 seconds
                    if (checkCount >= maxChecks) {
                        clearInterval(checkInterval);
                        youtubeWindow.close();
                        hideLoading();
                        showError('Timeout. Please make sure you\'re logged into YouTube and try again.');
                        resolve();
                    }
                }, 500);
                
                // Also show message to user
                setTimeout(() => {
                    if (!youtubeWindow.closed) {
                        showSuccess('ðŸ“º YouTube window opened. Please wait while we sync your session...');
                    }
                }, 1000);
            });
        }
        
        async function collectYouTubeCookies() {
            await authenticateYouTube();
        }
        
        function sendCookiesToBackend(cookieValue) {
            showLoading('Authenticating with YouTube...');
            
            fetch(API_BASE + '/api/set-cookies', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    cookies: cookieValue
                })
            })
            .then(res => res.json())
            .then(data => {
                hideLoading();
                if (data.success) {
                    localStorage.setItem('yt_authenticated', 'true');
                    document.getElementById('ytAuthBtn').classList.add('authenticated');
                    showSuccess('âœ“ YouTube authentication successful!');
                } else {
                    showError('âœ— Authentication failed: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(err => {
                hideLoading();
                showError('âœ— Error: ' + err.message);
            });
        }
        
        // Check auth on page load
        checkYouTubeAuth();

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('navbarDropdown');
            const menuBtn = document.getElementById('menuBtn');
            if (!e.target.closest('.navbar-menu-btn') && !e.target.closest('.navbar-dropdown')) {
                dropdown.classList.add('hidden');
            }
        });

        function scrollToSection(sectionId) {
            document.getElementById('navbarDropdown').classList.add('hidden');
            const section = document.querySelector('.platforms-section');
            if (section) {
                section.scrollIntoView({ behavior: 'smooth' });
            }
        }

        function openChatbot() {
            document.getElementById('chatbotModal').classList.remove('hidden');
            document.getElementById('navbarDropdown').classList.add('hidden');
        }

        function closeChatbot() {
            document.getElementById('chatbotModal').classList.add('hidden');
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            if (!message) return;

            // Add user message to chat
            const chatMessages = document.getElementById('chatMessages');
            const userMsgDiv = document.createElement('div');
            userMsgDiv.className = 'chat-message user-message';
            userMsgDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            chatMessages.appendChild(userMsgDiv);

            input.value = '';
            chatMessages.scrollTop = chatMessages.scrollHeight;

            try {
                const response = await fetch('http://localhost:3000/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userInput: message })
                });

                const data = await response.json();
                const botMsgDiv = document.createElement('div');
                botMsgDiv.className = 'chat-message bot-message';
                botMsgDiv.innerHTML = `<p>${escapeHtml(data.response || 'Unable to get response')}</p>`;
                chatMessages.appendChild(botMsgDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } catch (error) {
                console.error('Chat error:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'chat-message bot-message';
                errorDiv.innerHTML = `<p style="color: #ef4444;">Sorry, I'm unable to connect to the chatbot service. Please try again later.</p>`;
                chatMessages.appendChild(errorDiv);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Chat input enter key
        document.addEventListener('DOMContentLoaded', () => {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendChatMessage();
                    }
                });
            }
        });
    </script>
</body>
</html>